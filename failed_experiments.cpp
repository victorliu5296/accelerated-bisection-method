/*

This algorithm does not work to improve on bisection
I forgot to think

The Aitken-accelerated bisection method
- For finding the root of a continuous function f : Real to Real
    in an interval [a, b] (can be extended to ordered fields)
Here is the idea behind the algorithm:
We compute the sequence of the function f(x) in the interval [a, b] generated by
the bisection method. Based on this bisection sequence, we compute the Aitken
acceleration of the sequence of points.
Since the Aitken acceleration might not converge monotonically unlike the
bisection sequence, we need to use heuristics. Originally this is what I had
come up with:
"If a number of consecutive pairs of
points are getting closer as the Aitken acceleration sequence continues, this
might indicate that the Aitken acceleration is "settling down" and converging.
We use this to decide when to stop the Aitken acceleration. At that point, we
switch to bisection again, initialized with an interval centered at the last
Aitken-accelerated point to bracket the root. The radius of the interval will be
set to distance between the previous Aitken-accelerated point and the one before
that in hopes that if the sequence actually was settling down, then the root
will be contained in the interval."
On paper, it sounded good to me because I thought that the sequence would
progress somewhat stably towards the root. I was quite wrong.



Sequential description of the Aitken-accelerated bisection algorithm:
1. Initialize the interval [a, b] where f(a) and f(b) have opposite signs.
2. Compute the bisection sequence:
    - Calculate midpoint m = (a + b) / 2
    - Evaluate f(m)
    - Update interval: if f(m) has same sign as f(a), set a = m; otherwise, set b = m
3. Keep the last 3 points of the bisection sequence (x0, x1, x2).
4. Compute the Aitken acceleration:
    x_aitken = x2 - ((x2 - x1)^2) / (x2 - 2*x1 + x0)
        = x2 - (x2 - x1)^2 / ((x2 - x1) - (x1 - x0)) for numerical stability
    Keep track of the last 3 points of the Aitken acceleration sequence
5. Wait until the Aitken acceleration sequence is "settling down":
    - If the distance between the 2 last Aitken-accelerated points is less than
        the specified tolerance, proceed to step 6. Since we have the last 3
        points, might as well to check the distance between the last 2 pairs
        and check if they're getting closer together.
    - Otherwise, continue with step 2
6. Switch back to bisection:
    - Set the new interval center as the last Aitken-accelerated point
    - Set the interval radius as the distance between the previous Aitken-accelerated point
        and the one before that
    Iterate until desired accuracy is achieved or maximum iterations are reached.
7. Return the final approximation of the root.

Note: A bit arbitrarily, for sake of convenience, I've decided to write
x2, x1, x0 for x_{n+2}, x_{n+1}, x_n respectively. Similarly for the Aitken
sequence. They do not represent the points at indices 0, 1, and 2 of the
sequences.
*/

#include <iostream>
#include <iomanip>
#include <cmath>
#include <functional>
#include <chrono>
#include <vector>
#include <numeric>
#include <algorithm>
#include <tuple>
#include <random>
#include <sstream>
#include <string>

class RootFinder
{
private:
    static constexpr double TOLERANCE = 1e-10;
    static constexpr int MAX_ITERATIONS = 1000;
    static constexpr double RADIUS_MULTIPLIER = 8;

    static double aitken_accelerate(double x0, double x1, double x2)
    {
        double denominator = (x2 - x1) - (x1 - x0); // For numerical stability
        return (std::abs(denominator) < TOLERANCE) ? x2 : x2 - std::pow(x2 - x1, 2) / denominator;
    }

    static double bisection_step(double &a, double &b, double &fa, double &fb, const std::function<double(double)> &f, int &function_evaluations)
    {
        if (fa * fb > 0) // Covers a = b
        {
            std::ostringstream oss;
            oss << "Error: Function must have opposite signs at interval endpoints.\n";
            oss << "Values: a = " << a << ", b = " << b << ", fa = " << fa << ", fb = " << fb;
            throw std::runtime_error(oss.str());
        }

        double m = a + (b - a) / 2;
        double fm = f(m);
        function_evaluations++;

        if (fa * fm < 0) // Different signs: let compiler optimize
        {
            b = m;
            fb = fm;
        }
        else
        {
            a = m;
            fa = fm;
        }

        return m;
    }

    static bool is_settled(double x_aitken2, double x_aitken1, double x_aitken0)
    {
        double current_distance = std::abs(x_aitken2 - x_aitken1);
        double previous_distance = std::abs(x_aitken1 - x_aitken0);
        return current_distance < TOLERANCE && previous_distance < TOLERANCE && current_distance < previous_distance;
    }

public:
    struct Result
    {
        double root;
        int iterations;
        int function_evaluations;
    };

    static Result basic_bisection(const std::function<double(double)> &f, double a, double b)
    {
        double fa = f(a);
        double fb = f(b);
        int function_evaluations = 2; // Since f(a) and f(b) are evaluated

        for (int i = 0; i < MAX_ITERATIONS; ++i)
        {
            double m = bisection_step(a, b, fa, fb, f, function_evaluations);
            double interval_width = std::abs(b - a);
            if (interval_width < TOLERANCE)
            {
                return {m, i + 1, function_evaluations};
            }
        }

        throw std::runtime_error("Basic bisection method failed to converge within the maximum number of iterations");
    }

    static Result bisection(const std::function<double(double)> &f, double a, double b, double fa, double fb, int &function_evaluations)
    {
        function_evaluations += 2; // Since f(a) and f(b) are evaluated

        for (int i = 0; i < MAX_ITERATIONS; ++i)
        {
            double m = bisection_step(a, b, fa, fb, f, function_evaluations);
            double interval_width = std::abs(b - a);
            if (interval_width < TOLERANCE)
            {
                return {m, i + 1, function_evaluations};
            }
        }

        throw std::runtime_error("Basic bisection method failed to converge within the maximum number of iterations");
    }

    // Aitken acceleration method with cycling: keeping track of the last three points as 3 double variables
    static Result aitken_accelerated_bisection_cycling(const std::function<double(double)> &f, double a, double b)
    {
        double fa = f(a);
        double fb = f(b);
        int function_evaluations = 2;
        double x2 = a, x1 = a, x0 = a;
        double x_aitken2 = a, x_aitken1 = a, x_aitken0 = a;

        for (int i = 0; i < MAX_ITERATIONS; ++i)
        {
            // Bisection step
            double m = bisection_step(a, b, fa, fb, f, function_evaluations);
            x0 = x1;
            x1 = x2;
            x2 = m;

            double interval_width = std::abs(b - a);
            if (interval_width < TOLERANCE)
            {
                return {m, i + 1, function_evaluations};
            }

            // Aitken acceleration step
            if (i < 2) // Not enough points for Aitken acceleration yet
            {
                continue;
            }

            x_aitken2 = aitken_accelerate(x0, x1, x2);
            if (!is_settled(x_aitken2, x_aitken1, x_aitken0))
            {
                x_aitken1 = x_aitken2;
                x_aitken0 = x_aitken1;
                continue;
            }

            // If settled, switch back to bisection with a new interval centered at the last Aitken point
            double new_center = x_aitken2;
            double new_radius = std::abs(x_aitken1 - x_aitken0);

            a = new_center - new_radius;
            b = new_center + new_radius;
            fa = f(a);
            fb = f(b);
            function_evaluations += 2;
            if (fa * fb < 0)
            {
                return bisection(f, a, b, fa, fb, function_evaluations); // Finish with bisection method
            }

            a = new_center - RADIUS_MULTIPLIER * new_radius;
            b = new_center + RADIUS_MULTIPLIER * new_radius;
            fa = f(a);
            fb = f(b);
            function_evaluations += 2;
            if (fa * fb < 0)
            {
                return bisection(f, a, b, fa, fb, function_evaluations); // Finish with bisection method
            }
        }

        throw std::runtime_error("Aitken acceleration method (cycling) failed to converge within the maximum number of iterations");
    }

    // Aitken acceleration method with an array of doubles: keeping track of the last three points in an array, cycling through the indices
    static Result aitken_accelerated_bisection_array(const std::function<double(double)> &f, double a, double b)
    {
        double fa = f(a);
        double fb = f(b);
        int function_evaluations = 2;

        // Initialize an array to store the last three points
        double x[3] = {a, a, a};
        int index = 0; // Current index in the array

        // Initialize Aitken-accelerated points
        double x_aitken[3] = {a, a, a};

        for (int i = 0; i < MAX_ITERATIONS; ++i)
        {
            // Bisection step
            double m = bisection_step(a, b, fa, fb, f, function_evaluations);

            // Update the array with the new midpoint
            x[index] = m;
            index = (index + 1) % 3;

            double interval_width = std::abs(b - a);
            if (interval_width < TOLERANCE)
            {
                return {m, i + 1, function_evaluations};
            }

            // Aitken acceleration step
            if (i < 2) // Not enough points for Aitken acceleration yet
            {
                continue;
            }

            // Use the values stored in the array to compute the Aitken-accelerated value
            int prev_index1 = (index + 1) % 3;
            int prev_index2 = (index + 2) % 3;

            x_aitken[index] = aitken_accelerate(x[prev_index2], x[prev_index1], x[index]);

            // Check if the Aitken sequence is settling down
            if (is_settled(x_aitken[index], x_aitken[prev_index1], x_aitken[prev_index2]))
            {
                // If settled, switch back to bisection with a new interval centered at the last Aitken point
                double new_center = x_aitken[index];
                double new_radius = std::abs(x_aitken[prev_index1] - x_aitken[prev_index2]);

                a = new_center - new_radius;
                b = new_center + new_radius;
                fa = f(a);
                fb = f(b);
                function_evaluations += 2;
                if (fa * fb < 0)
                {
                    return bisection(f, a, b, fa, fb, function_evaluations); // Finish with bisection method
                }

                a = new_center - RADIUS_MULTIPLIER * new_radius;
                b = new_center + RADIUS_MULTIPLIER * new_radius;
                fa = f(a);
                fb = f(b);
                function_evaluations += 2;
                if (fa * fb < 0)
                {
                    return bisection(f, a, b, fa, fb, function_evaluations); // Finish with bisection method
                }
            }
        }

        throw std::runtime_error("Aitken acceleration method (array) failed to converge within the maximum number of iterations");
    }
};

class Benchmark
{
public:
    struct Result
    {
        double elapsed_time_us;
        int iterations;
        int function_evaluations;
        double root;
    };

    template <typename Func, typename... Args>
    static Result run(Func &&func, Args &&...args)
    {
        auto start_time = std::chrono::high_resolution_clock::now();
        auto result = func(std::forward<Args>(args)...);
        auto end_time = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end_time - start_time);
        return {duration.count() / 1000.0, result.iterations, result.function_evaluations, result.root};
    }

    static void benchmark(const std::function<double(double)> &f, double a, double b, int num_runs)
    {
        std::vector<Result> basic_results, cycling_results, array_results;

        try
        {
            for (int i = 0; i < num_runs; ++i)
            {
                basic_results.push_back(run(RootFinder::basic_bisection, f, a, b));
                cycling_results.push_back(run(RootFinder::aitken_accelerated_bisection_cycling, f, a, b));
                array_results.push_back(run(RootFinder::aitken_accelerated_bisection_array, f, a, b));
            }
        }
        catch (const std::exception &e)
        {
            std::cout << "Error: " << e.what() << "\n";
        }

        auto calculate_stats = [](const std::vector<Result> &results)
            -> std::tuple<double, double, double, double, double, double, double>
        {
            if (results.empty())
            {
                return std::make_tuple(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
            }
            std::vector<double> times;
            double sum_iterations = 0, sum_evaluations = 0;
            for (const auto &result : results)
            {
                times.push_back(result.elapsed_time_us);
                sum_iterations += result.iterations;
                sum_evaluations += result.function_evaluations;
            }
            double sum = std::accumulate(times.begin(), times.end(), 0.0);
            double mean = sum / times.size();
            double sq_sum = std::inner_product(times.begin(), times.end(), times.begin(), 0.0);
            double stdev = std::sqrt(sq_sum / times.size() - mean * mean);
            auto min_max = std::minmax_element(times.begin(), times.end());
            double avg_iterations = sum_iterations / results.size();
            double avg_evaluations = sum_evaluations / results.size();
            return std::make_tuple(mean, stdev, *min_max.first, *min_max.second, avg_iterations, avg_evaluations, results[0].root);
        };

        auto print_stats = [](const char *method, const std::tuple<double, double, double, double, double, double, double> &stats)
        {
            std::cout << method << " approach:\n"
                      << "  Mean time: " << format_with_commas(std::get<0>(stats)) << " microseconds\n"
                      << "  StdDev time: " << format_with_commas(std::get<1>(stats)) << " microseconds\n"
                      << "  Min time: " << format_with_commas(std::get<2>(stats)) << " microseconds\n"
                      << "  Max time: " << format_with_commas(std::get<3>(stats)) << " microseconds\n"
                      << "  Avg iterations: " << std::fixed << std::setprecision(2) << std::get<4>(stats) << "\n"
                      << "  Avg function evaluations: " << std::fixed << std::setprecision(2) << std::get<5>(stats) << "\n"
                      << "  Root approximation: " << std::setprecision(15) << std::get<6>(stats) << "\n";
        };

        print_stats("Basic Bisection", calculate_stats(basic_results));
        print_stats("Aitken Acceleration (Cycling)", calculate_stats(cycling_results));
        print_stats("Aitken Acceleration (Array)", calculate_stats(array_results));
    }

private:
    static std::string format_with_commas(double value)
    {
        std::ostringstream oss;
        oss << std::fixed << std::setprecision(2) << value;
        std::string str = oss.str();
        int n = str.find('.');
        for (int i = n - 3; i > 0; i -= 3)
            str.insert(i, ",");
        return str;
    }
};

// A more expensive function with a known root
double expensive_function(double x)
{
    return std::exp(std::cos(x)) + std::sin(x * x);
}

// Another example of an expensive function
double expensive_polynomial(double x)
{
    double result = 0;
    for (int i = 0; i < 1000; ++i)
    {
        result += std::pow(x, i) / std::tgamma(i + 1); // This is actually e^x - 1
    }
    return result;
}

// Another expensive function (Bessel function of the first kind)
double bessel_function(double x)
{
    double sum = 0.0;
    for (int n = 0; n < 50; ++n)
    {
        double term = std::pow(-1, n) * std::pow(x / 2, 2 * n) / (std::tgamma(n + 1) * std::tgamma(n + 1));
        sum += term;
    }
    return sum - 0.5; // Shift to have a root
}

int main()
{
    std::cout << "Benchmarking root-finding methods...\n\n";

    // Simple function: f(x) = x^2 - 2
    auto simple_function = [](double x)
    { return x * x - 2; };
    std::cout << "Simple function: f(x) = x^2 - 2\n";
    Benchmark::benchmark(simple_function, 1.0, 2.0, 10000);

    // Expensive function
    std::cout << "\nExpensive function: f(x) = e^cos(x) + sin(x^2)\n";
    Benchmark::benchmark(expensive_function, 2.0, 3.0, 1000);

    // Bessel function
    std::cout << "\nBessel function: J_0(x) - 0.5\n";
    Benchmark::benchmark(bessel_function, 0.0, 2.0, 1000);

    return 0;
}